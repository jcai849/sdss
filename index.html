<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" type="text/css" href="css/asciinema-player.css" />
	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h2 class="r-fit-text">Large Scale R</h2>
					<p>Jason Cairns</p>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Problem</h2>
				</section>
				<section>
					<ul>
						<li>Larger-than-memory dataset</li>
						<li>Novel model</li>
						<li>Complex algorithm</li>
						<aside class="notes">Expand on each - meaning and examples</aside>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">Feature Requirements</h2>
				</section>
				<section>
					<pre><code  data-trim data-line-numbers="1|2"><script type="text/template">
						data <- read.distributed.data("airlines")
						dglm(data)
					</script></code></pre>
				</section>
				<section>
					<pre><code><script type="text/template">
						dglm <- d(function(...) {
							...
						})
					</script></code></pre>
					<p>Bonus: Fast, Interactive, Familiar</p>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Landscape</h2>
				</section>
				<section>
					<h3>Spark</h3>
					<ul>
						<li>Heavyweight</li>
						<li><a
								href="https://spark.apache.org/docs/1.6.0/api/scala/index.html#org.apache.spark.mllib.regression.RidgeRegressionWithSGD">Model
								definition</a> beyond the skills of most statisticians</li>
					</ul>
				</section>
				<section>
					<h3>pbdDMAT</h3>
					<ul>
						<li>Very familiar high-level interface</li>
						<li>Built on MPI and ScaLAPACK for matrices</li>
					</ul>
				</section>
				<section>
					<h3>Dask</h3>
					<ul>
						<li>Mature System in Python</li>
						<li>Executable pseudocode, not executable math</li>
					</ul>
					<aside class="notes">Summarise the landscape here</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">New Solution Dependencies</h2>
				</section>
				<section>
					<h3>Supporting Concepts</h3>
					<img src="distobjref.svg" alt="xx"> </img>
					<ul>
						<li>Distributed object references chunks</li>
						<li>Computation sent to the data</li>
					</ul>
				</section>
				<section>
					<h3>Supporting Program Layers</h3>
					<ul>
						<li>Model definition: <pre><code>d(f)</code></pre></li>
						<li>Communication</li>
					</ul>
					<aside class="notes">Expand: meaning and examples</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Solution</h2>
				</section>
				<section>
					<h3>The Math</h3>
					\[\begin{aligned}
					\dot{x} &amp; = \sigma(y-x) \\
					\dot{y} &amp; = \rho x - y - xz \\
					\dot{z} &amp; = -\beta z + xy
					\end{aligned} \]
				</section>
				<section>
					<h3>Sequential Code</h3>
					<pre><code><script type="text/template">
						S <- function(kappa) function(alpha) pmax(alpha-kappa, 0) - pmax(-alpha-kappa, 0)
						p_norm <- function(p) function(x) sum(abs(x)^p)^(1/p)
						l1_norm <- p_norm(1)
						l2_norm <- p_norm(2)
						
						A <- matrix(runif(m*n), n, m)
						chunks_i <- tapply(seq(n), cut(seq(n), N), identity, simplify=F)
						A <- lapply(chunks_i, function(i, x) x[i,], A)
						b <- lapply(chunks_i, function(i, x) x[i], b)
					</script></code></pre>
				</section>
				<section>
					<h3>Parallel Code</h3>
					<pre><code><script type="text/template">
						S <- function(kappa) function(alpha) pmax(alpha-kappa, 0) - pmax(-alpha-kappa, 0)
						p_norm <- function(p) function(x) sum(abs(x)^p)^(1/p)
						l1_norm <- p_norm(1)
						l2_norm <- p_norm(2)
						
						dA <- read.dmatrix("filepath-A")
						db <- read.dmatrix("filepath-b")
					</script></code></pre>
				</section>
				<section>
					<h3>Sequential Code</h3>
					<pre><code><script type="text/template">
						lasso <- function(A, b, tolerance=1, rho=3, lambda=rho) {
							M_N <- dim(A)
							m <- ncol(A)
							S_z <- S(lambda/(rho*M_N[2]))
						
							z_prev <- rep(Inf, m)
							x_prev <- u_prev <- rep(list(z_prev), N)
							z_curr <- rep(1, m)
							x_curr <- u_curr <- rep(list(z_curr), N)
					</script></code></pre>
				</section>
				<section>
					<h3>Parallel Code</h3>
					<pre><code><script type="text/template">
						dlasso <- function(A, b, tolerance=1, rho=3, lambda=rho) {
							M_N <- dim(Ref(A))
							m <- ncol(A)
							S_z <- S(lambda/(rho*M_N[2]))
						
							z_prev <- x_prev <- u_prev <- rep(Inf, m)
						
							z_curr <- rep(1, m)
							x_curr <- distribute(z_curr, where=A); u_curr <- distribute(z_curr, where=A)
					</script></code></pre>
				</section>
				<section>
					<h3>Sequential Code</h3>
					<pre><code><script type="text/template">
						while (l1_norm(z_curr - z_prev) > tolerance) {
							x_prev <- x_curr; z_prev <- z_curr; u_prev <- u_curr
							x_curr <- mapply(x.update, x_prev, A, b, u_prev, MoreArgs = list(rho, z_prev), SIMPLIFY = FALSE)
							x_local <- unlist(x_curr); u_local <- unlist(u_curr); dim(x_local) <- dim(u_local) <- c(m, N)
							z_curr <- S_z(rowMeans(x_local) + rowMeans(u_local))
							u_curr <- mapply(function(u_prev, x_curr, z_curr) u_prev + x_curr - z_curr, u_prev, x_curr, MoreArgs = list(z_curr), SIMPLIFY = FALSE)
						}
						z_curr
					}
					</script></code></pre>
				</section>
				<section>
					<h3>Parallel Code</h3>
					<pre><code><script type="text/template">
						while (l1_norm(z_curr - z_prev) > tolerance) {
							x_prev <- x_curr; z_prev <- z_curr; u_prev <- u_curr
							x_curr <- d.x_update(x_prev, A, b, u_prev, rho, z_prev)
							dim(Ref(x_curr)) <- dim(Ref(u_curr)) <- M_N
							z_curr <- S_z(rowMeans(emerge(x_curr)) + rowMeans(emerge(u_curr)))
							u_curr <- u_prev + x_curr - z_curr
						}
						z_curr
					}
					</script></code></pre>
				</section>
				<section>
					<h3>Sequential Code</h3>
					<pre><code><script type="text/template">
						x_update <- function(x_prev, A, b, u_prev, rho, z_prev) {
							optim(x_prev,
								function(x_prev) (1/2)*l2_norm(A %*% x_prev - b)^2 +
												(rho/2)*l2_norm(x_prev - z_prev + u_prev)^2)$par
						}
					</script></code></pre>
				</section>
				<section>
					<h3>Parallel Code</h3>
					<pre><code><script type="text/template">
						d.x_update <- d(function(x_prev, A, b, u_prev, rho, z_prev) {
							optim(x_prev,
								function(x_prev) (1/2)*l2_norm(A %*% x_prev - b)^2 +
												(rho/2)*l2_norm(x_prev - z_prev + u_prev)^2)$par
						})
					</script></code></pre>
				</section>
				<section>
					<h3>The Code in Action</h3>
					<div id="asciicast" class="player"></div>
					<aside class="notes">Note the existence of lower communication layer - comment on elasticity, p2p
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>More on concepts, implementation etc. if there is time</h2>
					<ul>
						<li>master, slave etc.</li>
					</ul>
					<aside class="notes">Expand: meaning and examples</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">Close</h2>
				</section>
				<section>
					<h3>Conclusion</h3>
					<ul>
						<li>Key Takeaway: There's a new system in R that gets to the essence of distributed modelling,
							with interfaces at multiple layers</li>
						<li>Limitations:<ul>
								<li>Still in development</li>
								<li>No monitoring or resilience</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					QR code to contact me
				</section>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/math/math.js"></script>
	<script src="js/asciinema-player.min.js"></script>

	<script>
		Reveal.initialize({
			hash: true,
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
		});
		AsciinemaPlayer.create('lasso.cast', document.getElementById('asciicast'));
	</script>
</body>

</html>