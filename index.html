<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h2 class="r-fit-text">Large Scale R</h2>
					<p>Jason Cairns</p>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Problem</h2>
				</section>
				<section>
					<ul>
						<li>Larger-than-memory dataset</li>
						<li>Novel model</li>
						<li>Complex algorithm</li>
						<aside class="notes">Expand on each - meaning and examples</aside>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">Feature Requirements</h2>
				</section>
				<section>
					<pre><code  data-trim data-line-numbers="1|2|3|4"><script type="text/template">
						initialise_system()
						data <- ingest_data()
						processed_data <- manipulate(data)
						my_model(processed_data)
					</script></code></pre>
					<p>Bonus: Fast, Interactive, Familiar</p>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Landscape</h2>
				</section>
				<section>
					<h3>Spark</h3>
					<ul>
						<li>Heavyweight</li>
						<li><a
								href="https://spark.apache.org/docs/1.6.0/api/scala/index.html#org.apache.spark.mllib.regression.RidgeRegressionWithSGD">Model
								definition</a> beyond the skills of most statisticians</li>
					</ul>
				</section>
				<section>
					<h3>pbdDMAT</h3>
					<ul>
						<li>Very familiar high-level interface</li>
						<li>Built on MPI and ScaLAPACK for matrices</li>
					</ul>
				</section>
				<section>
					<h3>Dask</h3>
					<ul>
						<li>Mature System in Python</li>
						<li>Executable pseudocode, not executable math</li>
					</ul>
					<aside class="notes">Summarise the landscape here</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">New Solution Dependencies</h2>
				</section>
				<section>
					<h3>Supporting Concepts</h3>
					<ul>
						<li>Distributed chunks</li>
						<li>Distributed chunk array reference</li>
						<li>Distributed object</li>
						<li>Computation sent to the data</li>
					</ul>
				</section>
				<section>
					<h3>Supporting Program Layers</h3>
					<ul>
						<li>Model definition</li>
						<li>Communication</li>
					</ul>
					<aside class="notes">Expand: meaning and examples</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">The Solution</h2>
				</section>
				<section>
					<h3>The Math</h3>
					\[\begin{aligned}
					\dot{x} &amp; = \sigma(y-x) \\
					\dot{y} &amp; = \rho x - y - xz \\
					\dot{z} &amp; = -\beta z + xy
					\end{aligned} \]
				</section>
				<section>
					<h3>The Code</h3>
					<pre><code  data-trim data-line-numbers="11|12|13-17,19-23,25-31|18|24|1-9"><script type="text/template">
					d.x_update <- d(function(x_prev, A, b, u_prev, rho, z_prev) {
						p_norm <- function(p) function(x) sum(abs(x)^p)^(1/p)
						l2_norm <- p_norm(2)
						argmin <- function(init, f) optim(init, f)$par
	
						argmin(x_prev,
							function(x_prev) (1/2)*l2_norm(A %*% x_prev - b)^2 +
											(rho/2)*l2_norm(x_prev - z_prev + u_prev)^2)
					})
	
					dlasso <- function(A, b, tolerance=1, rho=3, lambda=rho) {
						M_N <- dim(chunkRef(A))
						m <- ncol(A)
						S_z <- S(lambda/(rho*M_N[2]))
					
						z_prev <- x_prev <- u_prev <- rep(Inf, m)
						z_curr <- rep(1, m)
						x_curr <- distribute(z_curr, where=A); u_curr <- distribute(z_curr, where=A)
						i <- 0
						while (l1_norm(z_curr - z_prev) > tolerance) {
							cat("Iteration: ", i <- i+1, '\n')
							x_prev <- x_curr; z_prev <- z_curr; u_prev <- u_curr
					
							x_curr <- d.x_update(x_prev, A, b, u_prev, rho, z_prev)
					
							dim(chunkRef(x_curr)) <- dim(chunkRef(u_curr)) <- M_N
					
							z_curr <- S_z(rowMeans(emerge(x_curr)) + rowMeans(emerge(u_curr)))
							u_curr <- u_prev + x_curr - z_curr
						}
						z_curr
					}
					</script></code></pre>
				</section>
				<section>
					<h3>The Code in Action</h3>
					<!-- Insert asciinema here -->
					<aside class="notes">Note the existence of lower communication layer - comment on elasticity, p2p</aside>
				</section>
			</section>
			<section>
				<section>
					<h2 class="r-fit-text">Close</h2>
				</section>
				<section>
					<h3>Conclusion</h3>
					<ul>
						<li>Key Takeaway: There's a new system in R that gets to the essence of distributed modelling, with interfaces at multiple layers</li>
						<li>Limitations:<ul>
							<li>Still in development</li>
							<li>No monitoring or resilience</li>
						</ul></li>
					</ul>
				</section>
				<section>
					QR code to contact me
				</section>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/math/math.js"></script>
	<script>
		Reveal.initialize({
			hash: true,
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
		});
	</script>
</body>

</html>